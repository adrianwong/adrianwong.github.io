---
layout: post
comments: true
title: SICP section 1.2 - procedures and the processes they generate
---

## Exercise 1.09
First definition is recursive:

```scheme
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

Second definition is iterative:

```scheme
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
```

## Exercise 1.11
Implementing *f* as a recursive process is fairly trivial:

```scheme
(define (fr n)
  (if (< n 3)
      n
      (+ (fr (- n 1))
         (+ (* 2 (fr (- n 2)))
            (* 3 (fr (- n 3)))))))
```

Implementing *f* as an iterative process is slightly trickier, but very similar to the iterative Fibonacci process covered in section 1.2.2. The idea is to use three integers `a`, `b` and `c`, initialised to `f(2) = 2`, `f(1) = 1` and `f(0) = 0` respectively. Applying the simultaneous equations:

* a <- a + 2b + 3c
* b <- a
* c <- b

Generalising, `a`, `b` and `c` are equal to `f(n + 2)`, `f(n + 1)` and `f(n)` respectively.

```scheme
(define (fi n)
  (fi-iter 2 1 0 n))

(define (fi-iter a b c n)
  (if (= n 0)
      c
      (fi-iter (+ a (* 2 b) (* 3 c))
               a
               b
               (- n 1))))
```

Testing that both processes output the same values:

```scheme
(define (test n)
  (if (= n 0)
      (= (fr 0) (fi 0))
      (and (= (fr n) (fi n)) (test (- n 1)))))
```

## Exercise 1.12
Note: this solution uses 1-based numbering for rows and columns. Key points:

* The number of columns in a given row is equal to the row number
* `val(r, c) = val(r-1, c-1) + val(r-1, c)`
* The recursive base cases are when `c == 1` or `c == r`, i.e. the edges of the triangle

```scheme
(define (pascal row col)
  (cond ((or (< col 1) (> col row)) 0) ; Error conditions
        ((or (= col 1) (= col row)) 1) ; Base cases
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))
```

## Exercise 1.16

## Exercise 1.19

## Exercise 1.22

## Exercise 1.23

## Exercise 1.24

## Exercise 1.25

## Exercise 1.26
