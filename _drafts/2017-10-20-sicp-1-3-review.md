---
layout: post
comments: true
exercises: 1.32, 1.33, 1.34, 1.37, 1.38, 1.39, 1.41, 1.42, 1.43, 1.44, 1.45, 1.46
title: SICP section 1.3 - formulating abstractions with higher-order procedures
---

{% include sicp.html %}

As the title suggests, this section is an introduction to higher-order procedures, i.e. procedures that can accept procedures as arguments or return procedures as values. TODO further explanation, consider making this a conclusion instead.

## Exercise 1.32
The more general form of the `sum` and `product` procedures can be defined (recursively) as follows:

```scheme
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
```

Redefining `sum` and `product` using `accumulate` is fairly straightforward. Note how the `null-value` arguments for `sum` and `product` are `0` and `1` respectively:

```scheme
(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))
```

The iterative counterpart of `accumulate` defines an internal procedure with two state variables - one tracks the value of `a`; the other accumulates the result, which is returned when the terminating condition `a > b` is met.

```scheme
(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-value))
```

## Exercise 1.33
The `filtered-accumulate` procedure is an even more general version of `accumulate` that only combines terms that satisfy a given condition.

```scheme
(define (filtered-accumulate combiner null-value term a next b filter)
  (define (next-fa)
    (filtered-accumulate combiner null-value term (next a) next b filter))
  (if (> a b)
      null-value
      (if (filter a)
          (combiner (term a)
                    (next-fa))
          (next-fa))))
```

Using this to define a procedure that computes the sum of the squares of prime numbers:

```scheme
(define (sum-square-prime a b)
  (filtered-accumulate + 0 square a inc b prime?))
```

...and a procedure that computes the product of integers less than `n` that are relatively prime to `n`:

```scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (identity n) n)

(define (product-rel-prime n)
  (define (rel-prime? a)
    (= (gcd a n) 1))
  (filtered-accumulate * 1 identity 1 inc (- n 1) rel-prime?))
```

## Exercise 1.34
Attempting to evaluate `(f f)` produces the following error:

```
mit-scheme : The object 2 is not applicable.

dr-racket  : application: not a procedure;
             expected a procedure that can be applied to arguments
             given: 2
             arguments...:
```

The cause of the error is made clearer by applying the substitution model:

```scheme
(define (f g) (g 2))

(f f)
(f 2)
(2 2)
```

The second invocation of `f` attempts to apply `2`, which is not a procedure, to `2`, resulting in an error.

## Exercise 1.37
For this exercise, I found that rewriting the *k-term finite continued fraction* as a single line helped me see more clearly how to implement it as a recursive process: f = N<sub>1</sub> / (D<sub>1</sub> + (N<sub>2</sub> / (D<sub>2</sub> + (N<sub>3</sub> / (D<sub>3</sub> + (... + (N<sub>k</sub> / D<sub>k</sub>))))))). 

```scheme
(define (cont-frac n d k)
  (define (frac x)
    (if (= x k)
        (/ (n x) (d x))
        (/ (n x) (+ (d x) (frac (+ x 1))))))
  (frac 1))
```

It takes 10 iterations to obtain an approximation of 1/Ï† accurate to 4 decimal places.

```scheme
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           10)
```

My implementation of this procedure's iterative counterpart decrements a counter that begins with `k` and returns the result when the counter equals `0`:

```scheme
(define (cont-frac-iter n d k)
  (define (frac x acc)
    (if (= x 0)
        acc
        (frac (- x 1) (/ (n k) (+ (d k) acc)))))
  (frac k 0))
```

## Exercise 1.38
We know that all values of N<sub>i</sub> are `1`. D<sub>i</sub> however, is slightly less straightforward. The (convoluted) pattern which I derived from the D<sub>i</sub> series is `2(i + 1)/3 if (i + 1) % 3 == 0 for i > 1`.

```scheme
(define (d i)
  (cond ((= i 1) 1)
        ((not (= (remainder (+ i 1) 3) 0)) 1)
        (else (/ (* 2 (+ i 1)) 3))))

(+ (cont-frac (lambda (i) 1.0)
              d
              10)
   2)
```

## Exercise 1.39
Fairly obvious patterns. N<sub>i</sub> = -x<sup>2</sup> for i > 1, and D<sub>i</sub> = 2i - 1.

```scheme
(define (tan-cf x k)
  (define (n k) (if (= k 1) x (- (square x))))
  (define (d k) (- (* 2.0 k) 1))
  (cont-frac n d k))
```

## Exercise 1.41

## Exercise 1.42

## Exercise 1.43

## Exercise 1.44

## Exercise 1.45

## Exercise 1.46
