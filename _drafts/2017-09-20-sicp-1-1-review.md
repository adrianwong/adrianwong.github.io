---
layout: post
comments: true
title: SICP section 1.1 - The Elements of Programming
---

This is the first of what I hope to be a total of 22 posts on SICP - each post corresponding to a section of the book. In these posts, my aim is to discuss points and exercises that I find to be particularly insightful and/or interesting.

In other words, I'm plagiarising [Eli Bendersky's idea](https://eli.thegreenplace.net/tag/sicp){:target="_blank"}, but I won't go to the depth he has with his posts.

### Exercise 1.05
```scheme
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))

; Evaluate:
(test 0 (p))

; Normal-order evaluation:
(test 0 (p))
(if (= 0 0) 0 (p))
(if (#t) 0 (p))
0

; Applicative-order evaluation:
(test 0 (p))
(test 0 (p))
(test 0 (p))
(test 0 (p)) ; Never terminates
```

Note 1: the definition of `(p)` is infinitely recursive.

Note 2: `if` is a special form. It evaluates the predicate, then evaluates the then-clause if the predicate evaluates to `#t`, *or* it evaluates the else-clause if the predicate evaluates to `#f`.

Normal-order evaluation does not evaluate the operands until the values are needed, but will instead expand the expression until it only consists of primitive operators. With normal-order evaluation, `(p)` is never evaluated - once the expression is fully expanded, `if` evaluates to true and the expression returns a value of `0`.

Applicative-order evaluation first evaluates the operator and operands, then applies the resulting procedure to the resulting arguments. This means that *all* expressions are evaluated prior to procedure application. With applicative-order evaluation, `(p)` is evaluated and proceeds to infinitely recurse.
